# -*- coding: utf-8 -*-
"""anime recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cttn6hZMWL-G22SK8M_u-_3DDH1PaW34

# Proyek Sistem Rekomendasi - Rekomendasi Anime

# Data Understanding

Import terlebih dahulu library yang akan digunakan
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

"""Memuat dataset yang akan digunakan"""

anime = pd.read_csv('/content/anime.csv')

# Menampilkan beberapa baris pertama untuk memeriksa struktur data
anime

"""Dataset memiliki 12.294 baris dan 7 kolom

# Exploratory Data Analysis

Menampilkan list variabel dalam dataset
"""

anime.info()

"""Variabel pada dataset terdiri dari:
- anime_id: ID unik untuk setiap anime
- name: Nama anime
- genre: Genre anime
- type: Tipe anime (seperti Movie atau TV)
- episodes: Jumlah episode
- rating: Rating anime
- members: Jumlah anggota yang menonton
"""

print('Jumlah anime: ', len(anime.name.unique()))

"""Terdapat 12.292 anime

## Kesalahan Tipe Data
Kolom episodes harus diubah dari object menjadi int64 karena merupakan variabel numerik. Namun, kolom episodes mengandung nilai yang tidak dapat dikonversi menjadi integer, seperti Unknown. Maka, perlu menangani nilai yang hilang terlebih dahulu sebelum mengonversinya ke tipe int64.
"""

# Imputasi nilai Unknown pada 'episodes' dengan modus (nilai yang paling sering muncul)
anime['episodes'] = anime['episodes'].replace('Unknown', pd.NA).fillna(anime['episodes'].mode()[0])

# Mengonversi kolom 'episodes' ke tipe integer
anime['episodes'] = anime['episodes'].astype('int64')

"""# Univariate Analysis

## Variabel Numerik
"""

# Menampilkan statistik deskriptif untuk kolom numerik
numeric_columns = ['rating', 'episodes', 'members']
numeric_summary = anime[numeric_columns].describe()

# Menampilkan statistik deskriptif
numeric_summary

"""- Rata-rata rating anime adalah sekitar 6.48
- Minimum rating adalah 1.67, dan maksimum adalah 10.
- Sebagian besar anime memiliki jumlah episode yang rendah, dengan rata-rata 12.43 episode. Hal ini menunjukkan bahwa banyak anime yang relatif singkat (misalnya, episode 12 adalah angka umum untuk season).
- Rata-rata jumlah anggota (members) anime adalah sekitar 18.159, dengan jumlah anggota yang sangat tinggi untuk anime populer (mencapai lebih dari 1 juta anggota).

### rating
"""

# Rating
plt.figure(figsize=(18, 6))
plt.subplot(1, 3, 1)
sns.histplot(anime['rating'], kde=True, bins=30, color='skyblue')
plt.title('Distribusi Rating')

plt.show()

"""- Distribusi rating terlihat normal, dengan puncak di sekitar nilai 6-7, menunjukkan bahwa sebagian besar anime mendapatkan penilaian yang cukup baik, tetapi tidak luar biasa tinggi.
- Ada outliers pada rating dengan beberapa anime mendapatkan rating 10 (terbaik), meskipun jumlahnya sangat sedikit.

### episodes
"""

# Episodes
plt.figure(figsize=(30, 6))
plt.subplot(1, 3, 2)
sns.histplot(anime['episodes'], kde=True, bins=30, color='lightgreen')
plt.title('Distribusi Episodes')

"""- Sebagian besar anime memiliki jumlah episode yang sangat sedikit, dengan banyak anime memiliki hanya satu episode (film) atau sedikit episode.
- Distribusi dengan log scale menunjukkan bahwa ada beberapa anime dengan jumlah episode yang sangat tinggi (misalnya, lebih dari 100 episode), tetapi ini sangat jarang terjadi.

### members
"""

# Members
plt.figure(figsize=(18, 6))
plt.subplot(1, 3, 3)
sns.histplot(anime['members'], kde=True, bins=30, color='salmon')
plt.title('Distribusi Members')

"""- Ada banyak anime dengan jumlah anggota yang sangat rendah, tetapi anime yang lebih populer mendapatkan jumlah anggota yang jauh lebih tinggi.
- Terdapat skewness yang kuat, dengan beberapa anime yang sangat populer menambah jumlah anggota secara signifikan.

## Variabel Kategorikal

### Genre
"""

# Menampilkan frekuensi untuk kolom 'genre'
genre_counts = anime['genre'].value_counts()

# Menampilkan hasil frekuensi untuk genre
genre_counts.head()

# Genre
plt.figure(figsize=(12, 8))
plt.subplot(2, 2, 1)
genre_counts.plot(kind='barh', color='blue')
plt.title('Distribusi Genre')
plt.xlabel('Jumlah Anime')

"""- Genre anime sering kali memiliki beberapa kombinasi genre, seperti "Action, Comedy, Drama", yang menunjukkan bahwa banyak anime dapat digolongkan dalam lebih dari satu kategori.
- Genre yang paling sering muncul adalah Hentai, Comedy, dan Music, yang menunjukkan bahwa genre-genre ini paling umum dalam dataset.
- Heterogenitas genre (beragamnya kombinasi genre) menunjukkan bahwa penonton anime mungkin memiliki selera yang sangat beragam, dan anime sering kali menarik dari berbagai jenis cerita atau tema.

### Type
"""

# Menampilkan frekuensi untuk kolom 'type'
type_counts = anime['type'].value_counts()

# Menampilkan hasil frekuensi untuk genre
type_counts.head()

# Type
plt.figure(figsize=(12, 8))
plt.subplot(2, 2, 2)
type_counts.plot(kind='bar', color='lightgreen')
plt.title('Distribusi Type')
plt.xlabel('Type')
plt.ylabel('Jumlah Anime')
plt.show()

"""- Jenis anime yang paling banyak ditemukan adalah TV dan OVA, yang menunjukkan bahwa sebagian besar anime dalam dataset ini adalah serial anime dengan durasi lebih panjang atau produksi khusus.
- Movie, Special, dan ONA hadir dalam jumlah yang lebih sedikit, yang menunjukkan bahwa anime dalam format-film atau spesial lebih jarang dibandingkan dengan serial TV.

# Data Preparation

## Mengatasi Missing Value
"""

anime.isna().sum()

"""Seperti yang kita lihat, variabel genre, type, dan rating memiliki beberapa missing value. Karena jumlah missing values tidak terlalu banyak dapat dilakukan penghapusan pada missing values."""

anime.dropna(subset=['genre', 'type', 'rating'], inplace=True)

"""Cek kembali ukuran dataset setelah penghapusan."""

anime.shape

"""Setelah penghapusan masih ada 12017 entri yang cukup untuk dilakukan analisis lebih lanjut."""

anime.isna().sum()

"""Sekarang, dataset memiliki 0 missing values.

## Duplikasi Data
"""

anime['name'].value_counts()

"""Dapat dilihat ada beberapa anime yang tercatat lebih dari satu, maka dari itu kita perlu melakukan drop agar hasil rekomendasi lebih akurat."""

anime = anime[~anime['name'].duplicated(keep='first')]

"""Pengecekan kembali untuk data duplikat."""

anime['name'].value_counts()

"""Dapat dilihat bahwa sudah tidak ada data duplikat.

## Feature Engineering

Kita akan memilih kolom yang relevan terlebih dahulu
"""

rec_anime = anime[['anime_id', 'name', 'genre']]
rec_anime.head()

""" Lalu, dilakukan pembersihan dan standarisasi kolom genre untuk memastikan konsistensi format. Proses ini penting untuk TF-IDF Vectorization karena tanda hubung dan spasi berpengaryh"""

# Mengambil genre yang unik setelah memecah genre yang dipisah dengan koma
all_genres = anime['genre'].str.split(', ').explode().unique()

# Menampilkan semua genre yang ada
print(all_genres)

# Mengganti genre tertentu dengan nama genre yang lebih konsisten
rec_anime.loc[rec_anime['genre'].str.contains('Drama', na=False), 'genre'] = rec_anime['genre'].str.replace('Drama', 'drama')
rec_anime.loc[rec_anime['genre'].str.contains('Romance', na=False), 'genre'] = rec_anime['genre'].str.replace('Romance', 'romance')
rec_anime.loc[rec_anime['genre'].str.contains('School', na=False), 'genre'] = rec_anime['genre'].str.replace('School', 'school')
rec_anime.loc[rec_anime['genre'].str.contains('Supernatural', na=False), 'genre'] = rec_anime['genre'].str.replace('Supernatural', 'supernatural')
rec_anime.loc[rec_anime['genre'].str.contains('Action', na=False), 'genre'] = rec_anime['genre'].str.replace('Action', 'action')
rec_anime.loc[rec_anime['genre'].str.contains('Adventure', na=False), 'genre'] = rec_anime['genre'].str.replace('Adventure', 'adventure')
rec_anime.loc[rec_anime['genre'].str.contains('Fantasy', na=False), 'genre'] = rec_anime['genre'].str.replace('Fantasy', 'fantasy')
rec_anime.loc[rec_anime['genre'].str.contains('Magic', na=False), 'genre'] = rec_anime['genre'].str.replace('Magic', 'magic')
rec_anime.loc[rec_anime['genre'].str.contains('Military', na=False), 'genre'] = rec_anime['genre'].str.replace('Military', 'military')
rec_anime.loc[rec_anime['genre'].str.contains('Shounen', na=False), 'genre'] = rec_anime['genre'].str.replace('Shounen', 'shounen')
rec_anime.loc[rec_anime['genre'].str.contains('Comedy', na=False), 'genre'] = rec_anime['genre'].str.replace('Comedy', 'comedy')
rec_anime.loc[rec_anime['genre'].str.contains('Historical', na=False), 'genre'] = rec_anime['genre'].str.replace('Historical', 'historical')
rec_anime.loc[rec_anime['genre'].str.contains('Parody', na=False), 'genre'] = rec_anime['genre'].str.replace('Parody', 'parody')
rec_anime.loc[rec_anime['genre'].str.contains('Samurai', na=False), 'genre'] = rec_anime['genre'].str.replace('Samurai', 'samurai')
rec_anime.loc[rec_anime['genre'].str.contains('Sci-Fi', na=False), 'genre'] = rec_anime['genre'].str.replace('Sci-Fi', 'scifi')
rec_anime.loc[rec_anime['genre'].str.contains('Thriller', na=False), 'genre'] = rec_anime['genre'].str.replace('Thriller', 'thriller')
rec_anime.loc[rec_anime['genre'].str.contains('Sports', na=False), 'genre'] = rec_anime['genre'].str.replace('Sports', 'sports')
rec_anime.loc[rec_anime['genre'].str.contains('Super Power', na=False), 'genre'] = rec_anime['genre'].str.replace('Super Power', 'superpower')
rec_anime.loc[rec_anime['genre'].str.contains('Space', na=False), 'genre'] = rec_anime['genre'].str.replace('Space', 'space')
rec_anime.loc[rec_anime['genre'].str.contains('Slice of Life', na=False), 'genre'] = rec_anime['genre'].str.replace('Slice of Life', 'sliceoflife')
rec_anime.loc[rec_anime['genre'].str.contains('Mecha', na=False), 'genre'] = rec_anime['genre'].str.replace('Mecha', 'mecha')
rec_anime.loc[rec_anime['genre'].str.contains('Music', na=False), 'genre'] = rec_anime['genre'].str.replace('Music', 'music')
rec_anime.loc[rec_anime['genre'].str.contains('Mystery', na=False), 'genre'] = rec_anime['genre'].str.replace('Mystery', 'mystery')
rec_anime.loc[rec_anime['genre'].str.contains('Seinen', na=False), 'genre'] = rec_anime['genre'].str.replace('Seinen', 'seinen')
rec_anime.loc[rec_anime['genre'].str.contains('Martial Arts', na=False), 'genre'] = rec_anime['genre'].str.replace('Martial Arts', 'martialarts')
rec_anime.loc[rec_anime['genre'].str.contains('Vampire', na=False), 'genre'] = rec_anime['genre'].str.replace('Vampire', 'vampire')
rec_anime.loc[rec_anime['genre'].str.contains('Shoujo', na=False), 'genre'] = rec_anime['genre'].str.replace('Shoujo', 'shoujo')
rec_anime.loc[rec_anime['genre'].str.contains('Horror', na=False), 'genre'] = rec_anime['genre'].str.replace('Horror', 'horror')
rec_anime.loc[rec_anime['genre'].str.contains('Police', na=False), 'genre'] = rec_anime['genre'].str.replace('Police', 'police')
rec_anime.loc[rec_anime['genre'].str.contains('Psychological', na=False), 'genre'] = rec_anime['genre'].str.replace('Psychological', 'psychological')
rec_anime.loc[rec_anime['genre'].str.contains('Demons', na=False), 'genre'] = rec_anime['genre'].str.replace('Demons', 'demons')
rec_anime.loc[rec_anime['genre'].str.contains('Ecchi', na=False), 'genre'] = rec_anime['genre'].str.replace('Ecchi', 'ecchi')
rec_anime.loc[rec_anime['genre'].str.contains('Josei', na=False), 'genre'] = rec_anime['genre'].str.replace('Josei', 'josei')
rec_anime.loc[rec_anime['genre'].str.contains('Shounen Ai', na=False), 'genre'] = rec_anime['genre'].str.replace('Shounen Ai', 'shounenai')
rec_anime.loc[rec_anime['genre'].str.contains('Game', na=False), 'genre'] = rec_anime['genre'].str.replace('Game', 'game')
rec_anime.loc[rec_anime['genre'].str.contains('Dementia', na=False), 'genre'] = rec_anime['genre'].str.replace('Dementia', 'dementia')
rec_anime.loc[rec_anime['genre'].str.contains('Harem', na=False), 'genre'] = rec_anime['genre'].str.replace('Harem', 'harem')
rec_anime.loc[rec_anime['genre'].str.contains('Cars', na=False), 'genre'] = rec_anime['genre'].str.replace('Cars', 'cars')
rec_anime.loc[rec_anime['genre'].str.contains('Kids', na=False), 'genre'] = rec_anime['genre'].str.replace('Kids', 'kids')
rec_anime.loc[rec_anime['genre'].str.contains('Shoujo Ai', na=False), 'genre'] = rec_anime['genre'].str.replace('Shoujo Ai', 'shoujoai')
rec_anime.loc[rec_anime['genre'].str.contains('Hentai', na=False), 'genre'] = rec_anime['genre'].str.replace('Hentai', 'hentai')
rec_anime.loc[rec_anime['genre'].str.contains('Yaoi', na=False), 'genre'] = rec_anime['genre'].str.replace('Yaoi', 'yaoi')
rec_anime.loc[rec_anime['genre'].str.contains('Yuri', na=False), 'genre'] = rec_anime['genre'].str.replace('Yuri', 'yuri')

# Menampilkan beberapa baris pertama dari dataset setelah penggantian genre
rec_anime.head()

"""Mengubah kolom menjadi list"""

anime_id = rec_anime['anime_id'].tolist()

anime_name = rec_anime['name'].tolist()

anime_genre = rec_anime['genre'].tolist()

"""# Model Development CBF"""

# Membuat dictionary untuk data , 'anime_id', 'name', 'genre'
anime_new = pd.DataFrame({
    'id': anime_id,
    'name': anime_name,
    'genre': anime_genre
})
anime_new.head()

"""## One Hot Encoding

Penerapan one hot encoding pada genre, 0 berarti genre tidak ada pada anime, 1 berarti ada.
"""

genre_list = []

# Membuat daftar genre unik
for index in anime_new.index:
    temp = anime_new['genre'][index].split(',')
    for i in temp:
        if i not in genre_list:
            genre_list.append(i)

onehot_df = pd.DataFrame(0, index=anime_new.index, columns=genre_list)

# Mengisi nilai 1 untuk genre yang sesuai
for index in anime_new.index:
    temp = anime_new['genre'][index].split(',')
    for i in temp:
        onehot_df.loc[index, i] = 1

anime_new = pd.concat([anime_new, onehot_df], axis=1).fillna(0)
anime_new.head()

"""## TF-IDF Vectorizer

TF-IDF Vectorizer digunakan untuk mengubah teks (seperti genre game) menjadi representasi numerik yang dapat diproses oleh model machine learning. Teknik ini menghitung dua hal: Term Frequency (TF), yang mengukur seberapa sering genre muncul dalam sebuah game, dan Inverse Document Frequency (IDF), yang mengukur seberapa penting genre tersebut dalam keseluruhan dataset. Dengan menggunakan TF-IDF, genre yang lebih jarang muncul mendapat bobot lebih tinggi, sementara genre yang sering muncul diberi bobot rendah.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tf.fit(anime_new['genre'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(anime_new['genre'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan genre
# Baris diisi dengan nama anime

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=anime_new.name
).sample(22, axis=1).sample(10, axis=0)

"""## Cosine Similarity
- Menghitung cosine similarity antara semua pasangan anime
- Menghasilkan similarity matrix yang akan digunakan untuk rekomendasi
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa title game
cosine_sim_df = pd.DataFrame(cosine_sim, index=anime_new['name'], columns=anime_new['name'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap game
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Game dengan nilai similarity tinggi (mendekati 1) akan lebih relevan untuk direkomendasikan.

## Euclidean Distance
"""

from sklearn.metrics.pairwise import euclidean_distances

euclidean_sim = euclidean_distances(tfidf_matrix)
euclidean_sim

"""Matriks ini menggambarkan representasi dokumen dalam bentuk vektor, di mana setiap baris mewakili sebuah dokumen dan setiap kolom mewakili sebuah kata dalam korpus. Nilai di dalam matriks adalah skor TF-IDF, yang mengukur seberapa penting suatu kata dalam dokumen tertentu."""

euclidean_sim_df = pd.DataFrame(euclidean_sim, index=anime_new['name'], columns=anime_new['name'])
print('Shape:', euclidean_sim_df.shape)

euclidean_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Output euclidean_sim adalah matriks jarak Euclidean antara semua pasangan. Semakin kecil nilai Euclidean Distance, semakin mirip game tersebut

## Rekomendasi dengan Cosine Similarity
"""

def anime_cosine(anime_name, similarity_data=cosine_sim_df, items=anime_new[['name', 'genre']], k=10):
    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,anime_name].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop name agar title game yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(anime_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

rec_anime[rec_anime.name.eq('Shingeki no Kyojin')]

anime_cosine('Shingeki no Kyojin')

"""Dapat kita lihat bahwa rekomendasi yang diberikan sangat relevan dan memiliki genre yang mirip.

## Rekomendasi dengan Euclidean Distance
"""

def anime_euclidean(anime_name, similarity_data=euclidean_sim_df, items=anime_new[['name', 'genre']], k=10):
    similarity_scores = similarity_data[anime_name].to_numpy()

    closest_indices = similarity_scores.argsort()[:k]

    closest_animes = similarity_data.columns[closest_indices]

    closest_animes = closest_animes.drop(anime_name, errors='ignore')

    if len(closest_animes) < k:
        additional_animes = similarity_data.columns[similarity_scores.argsort()[k:2*k]]
        closest_animes = closest_animes.append(additional_animes).drop_duplicates()

    result_euclidean = pd.DataFrame(closest_animes[:k], columns=['name'])

    result_euclidean = result_euclidean.merge(items, on='name', how='left')

    return result_euclidean.head(k)

rec_anime[rec_anime.name.eq('Death Note')]

anime_euclidean('Death Note')

"""Dapat kita lihat bahwa rekomendasi yang diberikan sangat relevan dan memiliki genre yang mirip.

## Precision Model
"""

relevant_animes = anime[anime['genre'].str.contains('Action') | anime['genre'].str.contains('Mystery')]
actual_relevant = relevant_animes['name'].tolist()

cosine_recommended = anime_cosine('Shingeki no Kyojin')['name'].tolist()  # 10 rekomendasi dengan Cosine Similarity
euclidean_recommended = anime_euclidean('Death Note')['name'].tolist()  # 10 rekomendasi dengan Euclidean Distance

print("Cosine Similarity Recommends:", cosine_recommended)
print("Euclidean Distance Recommends:", euclidean_recommended)

def precision_at_k(recommended, actual, k=10):
    relevant_items = sum([1 for anime in recommended[:k] if anime in actual])
    precision = relevant_items / k if k > 0 else 0
    return precision

precision_cosine = precision_at_k(cosine_recommended, actual_relevant, k=10)
precision_euclidean = precision_at_k(euclidean_recommended, actual_relevant, k=10)

# Menampilkan hasil Precision dan Recall
print(f"Precision at k for Cosine Similarity: {precision_cosine:.2f}")
print(f"Precision at k for Euclidean Distance: {precision_euclidean:.2f}")

"""Hasil perbandingan precision ini menunjukkan bahwa semua rekomendasi yang diberikan oleh kedua metode adalah relevan dan termasuk dalam 10 rekomendasi teratas. Dengan kata lain, kedua model berhasil memberikan hanya rekomendasi yang relevan dalam daftar rekomendasi teratas mereka."""